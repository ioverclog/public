import React, {Component} from 'react';
import PropTypes from 'prop-types';
import LogService from 'services/LogService';
import {AppInfoService} from 'services/deviceInfo';

import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';
import { ActionCreators as HomeTabsActionCreators } from 'app/HomeTab/HomeTabs';
import { ActionCreators as TabMenuActionCreators } from 'app/common/HomeTabMenu/TabMenus';

let Utils = {
    getTranslate : (el) => {
       let matrix;
       let curTransform;
       let transformMatrix;
       let win = window;

       let curStyle = window.getComputedStyle(el, null);
       
       if(win.WebKitCSSMatrix) {
          curTransform = curStyle.transform || curStyle.webkitTransform;
          if (curTransform.split(',').length > 6) {
              curTransform = curTransform.split(', ').map(function (a) { return a.replace(',', '.'); }).join(', ');
          }
          // Some old versions of Webkit choke when 'none' is passed; pass
          // empty string instead in this case
          transformMatrix = new win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
       } else {
          transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
          matrix = transformMatrix.toString().split(',');
       }
    }
    
    // Latest Chrome and webkits Fix
    if (win.WebKitCSSMatrix) { curTransform = transformMatrix.m41; }
    // Crazy IE10 Matrix
    else if (matrix.length === 16) { curTransform = parseFloat(matrix[12]); }
    //Normal Browsers
    else { curTransform = parseFloat(matrix[4]); }

    //curTransform = Number(window.getComputedStyle(this.swipeRootElement).transform.split(',')[4] || 0) //getComputedStyle 은 PX 값을 return 한다.
    return curTransform || 0;
    },
    getRandomStart : ( length ) => {
        let index = 0;
        if( length > 1 ){
            index = Math.floor((Math.random() * length) + 1) - 1;
        }
        return index;
    }
};

class Swiper extends Component {
    constructor(props) { 
       super(props);
       
       this._endTransition = this._endTransition.bind(this);
      
       this.winWidth = window.innerWidth;
       this.interval = null;
       this.valid = true;
       this.isTransition = false;
       this.currentIndex = 0;

       this.slides = [];
       this.slideInnerXpos = [];
       
       this.swipeRootElement = null;//ref element 저장 //componentDidMount 이후 실행됨
       this.$remoteSwiper = null;
       this.direction = 'next';

       this.isStopPropagation = true;
       this.animationFrame = null;

       this.isScrolling = undefined;//touchMove 시 1회만 발생
       this.isRemoteMove = false;
  
       //no loop일 경우, touch start할 때, 최초 위치값을 구하기 위해 필요하다. 기존 값 + 현재 값.
       this.sohoStyleCurrentPos = 0;
       this.playAnimation = true;

       if(this.props.idClass.indexOf('search-tab-swipe') > -1){
           this.isAbsolutePostionMode = true;
       }

       this.state = {
           autoPlay : this.props.autoPlay
       }
    }
    _update() {
        if( !this.props.isFreeContainer ) {
            this._getSlides();
            this._setSlidePos();//최초 1회 필요 (change position mode일 때)
            this._changePropsIfSlideOnlyOne();
            // Position 초기화
            this._setInitCurrentIndex();
            this._changePagenation();
            this.startAutoPlay();
            if( this.slides.length > 1 ) this._chagePositions();
            //this.lastSwipeLength = this.props.children.length % this.props.viewContLength;//전체 개수 / 화면 표출 개수
            this.canSwipeNum = Math.ceil(this.slides.length / this.props.viewContLength); //Swipe 가능 개수
        }

        this.minXpos = 0;
        this.maxXpos = -(this.swipeRootElement.clientWidth - this.winWidth);
    }

    /** *********** Life Cycle *********** **/
    componentDidMount(){
        this._update();
    }
    componentWillUnmount() {
        this._pause();
        this._stopTransform();
        this.swipeRootElement.removeEventListener("transitionend", this._endTransition, false);
    }

    getRemoteDistance( nextProps ) {
        this.isRemoteMove = true;
        this.direction = nextProps.direction;
        let distance = (this.direction == 'prev')? this.slideWidth : -this.slideWidth;
        if( nextProps.distance == 0 ){
            distance = 0;
        }
        return distance
    }
    componentWillReceiveProps( nextProps ){
        //home-swipe > touch end 시 실행
        if( this.props.idClass == 'header-swipe' ){  
            if( nextProps.triggerSyncMoveEnd != this.props.triggerSyncMoveEnd ){//triggered Remote Touch End
                let distance = this.getRemoteDistance(nextProps);
                this._playMovingForHome( distance, 'touchend' );
            }
        }
        //Nav Click 시 실행
        if( this.props.idClass == 'header-swipe' || this.props.idClass == 'home-swipe' ){
            if( nextProps.isTriggeredInHomeSwipe != this.props.isTriggeredInHomeSwipe ){
                this.gotoSlide( nextProps.currentTab );
                //LOGGING
                if( this.props.idClass == 'home-swipe' ) {
                    this._sendLogsNew(nextProps.currentTab)
                }
            }
        }

        if( this.props.idClass == 'app-nav-home' && this.props.currentTab != nextProps.currentTab ){
            this.gotoPosition(nextProps.initIndex);
        }

        //Swipe 가 화면에 표출될 때만 Auto Play
        if( this.props.idClass == 'home-event' ){
            if( nextProps.currentTab == 0 ){
                this.startExternalAutoPlay();
            } else {
                this._pause();
            }
        }

        if( this.props.idClass == 'style-mds-pick' ){
            if( nextProps.currentTab == 5 ){
                this.startExternalAutoPlay();
            } else {
                this._pause();
            }
        }
    }
    componentDidUpdate( prevProps, prevStat ){
         //TODO 최적화 필요
         if(this.slides.length != this.swipeRootElement.children.length){
             this._update();
         }
    }

    _animate({timing, draw, duration}) {
        let start = window.performance.now();
        let animate;
        this.animationFrame = requestAnimationFrame(animate = (time) =>{
            // timeFraction goes from 0 to 1
            let timeFraction = (time - start) / duration;
             
            if(timeFraction < 0){
                timeFraction = 0;
            }

            if (timeFraction > 1) {
                timeFraction = 1;
            }

            let result = 100 - (timeFraction * 100);

            // calculate the current animation state
            let progress = timing(result);

            draw(progress); // draw it

            if (timeFraction < 1 && this.playAnimation ) {
                requestAnimationFrame(animate);
            }
        });
    }
    _stopAnimation() {
        this.playAnimation = false;
        if( this.animationFrame ){
            cancelAnimationFrame(this.animationFrame);
        }
    }

    /** ******* Event Listener ******** **/
    _touchStart(evt) {
        this._stopAnimation();//for javascript freemode
        this._pause();//stop auto play

        if( this.props.idClass == 'header-swipe' || this.isTransition ){
            return;
        }
   
        if ( this.props.children.length > 1 && this.valid ) {
            this.startCoords = evt.touches[0];
            this.curX = this.startCoords.clientX;
            this.startEvent = Object.assign({}, evt);

            /** For Free Mode **/
            if( this.props.isFreeContainer || this.props.idClass == 'soho-swipe' ) {
                this.currentXpos = Utils.getTranslate( this.swipeRootElement );
            }
        }

        if( !this.$remoteSwiper && this.props.idClass == 'home-swipe' ){
            this.$remoteSwiper = document.querySelector('.header-swipe > .swiper-wrapper');
        }

        this.valid = false;
        this._setEventPropagation( evt );
    }
    _touchMove(evt) {
        if ( this.props.children.length > 1 ) {
            if( this.props.idClass == 'header-swipe' || this.isTransition ){
                return;
            }

            let moveCoords = evt.touches[0];
            this.curX = moveCoords.clientX;

            this._validSwipe( moveCoords );//this.isScrolling 셋팅
            
            if( this.isScrolling ){
                if( !this.props.loop ){
                    /** Style 탭 > Swipe **/
                    this._moveSohoSwipe( evt );
 
                } else if( this.props.isFreeContainer ) {
                    /** Free Mode **/
                    this._stopAnimation();
                    this._moveFreeScroll( evt );
               
                } else {
                    //For Two Slide
                    if( this.canSwipeNum == 2 ){
                        this._changeDirection();
                    }
                    /** Default Mode **/
                    this._moveDefaultSwipe( evt );
                }
                this.valid = true;
            }
        }
        
        this._setEventPropagation( evt );
    }
    _touchCancel() {
        this.valid = false;
        this.isTransition = false;
    }
    _touchEnd(evt) {
        if ( this.props.children.length > 1 && this.valid ) {
            if( this.props.idClass == 'header-swipe' || this.isTransition ){
                return;
            }
            
            let endCoords = evt.changedTouches[0];
            this.curX = endCoords.clientX;
            
            /** Style > 3 view Swipe **/
            if( !this.props.loop ){
                let distance = this._setSohoSwipeMoveDistance();
                this._playMoving( distance, 'touchend' );
                
            } else if( this.props.isFreeContainer ){
            /** For Free Mode **/
                this._stopAnimation();
                this._freeModeAnimation( evt );//no exec if stop time is long
            } else {
            /** Default **/
                let distance = this._setDefalutMoveDistance();
                this._playMoving( distance, 'touchend' );
                
                if( this.props.idClass == 'home-swipe' ){
                    this._remoteTouchEnd( distance );
                }
            }           
        }
        
        this.valid = true;
        this.isScrolling = undefined;
        
        if( !this.props.isFreeContainer && this.state.autoPlay ) {
            this._play();
        }
        
        this._setEventPropagation( evt );
    }
    //상품 클릭, 새 창 뜨면, auto swipe가 멈추는 것 해결
    _onClick(evt) {
        evt.preventDefault();
        evt.stopPropagation();
        
        if( !this.props.isFreeContainer && this.props.idClass != 'header-swipe' ) {
            this._play();
        }
    }
    
    /** ***************** Private Method ***************** **/
    //TouchMove Type
    _moveSohoSwipe( evt ) {
        //save position needed
        this._setMovePosX( evt );//this is needed for direction in touchEnd
        
        let easing = 0.43;
        let posX = (this.curX - this.startCoords.clientX) / this.winWidth * 100 * easing;
        
        //Soho Swipe
        posX = posX + this.sohoStyleCurrentPos; //% unit (entire screen is 100%)
        
        // 2) move controll
        let checkPosX = (this.curX - this.startCoords.clientX); //PX unit
        checkPosX = checkPosX + this.currentXpos;//current transform % position
        
        //left, right No Scroll
        if( checkPosX < this.minXpos && checkPosX > this.maxXpos ){
            this._transformAnimation( posX, 'touchmove' );//% unit
        }
    }
    _moveFreeScroll( evt ) {
        this._setMovePosX( evt );//this is needed in animation for direction
        
        // 2) move controll
        let posX = (this.curX - this.startCoords.clientX) + this.currentXpos; //PX unit
        
        //result value of Move(this is needed in free animation)
        this.moveLastPos = posX;
        
        //left, right No Scroll
        if( posX <= this.minXpos && posX >= this.maxXpos ){
            this._transformAnimation( posX, 'touchmove' );
        } else {
            evt.preventedByNestedSwiper = true;
        }
    }
    _moveDefaultSwipe( evt ) {
        //save needed position
        this._setMovePosX( evt );//this is needed in touchend for direction
        let posX = (this.curX - this.startCoords.clientX) / this.winWidth * 100; //% unit
        this._transformAnimation( posX, 'touchmove' );
        
        //async with Header Swipe
        if( this.props.idClass == 'home-swipe' ){
            let duration = '0ms';
            if( this.$remoteSwiper ){
                //0) Swiper-wrapper Move
                let unit = this._getUnit();
                this._setTransform(posX, unit, duration, this.$remoteSwiper);
                
                //1) move entire each swiper-slide
                for(let i=0; i<6; i++){
                    let $innerSlide = this.$remoteSwiper.children[i].children[0];
                    let to = this.slideInnerXpos[i] - posX;
                    if( $innerSlide ) {
                        this._setTransform( to, unit, duration, $innerSlide );
                    }
                }
            }
            this.valid = true;//touchEnd can trigger if moving is over;
            this.isTransition = false;
        }
    }
    _moveDefaultHomeSwipe( evt ) {
        //save needed position
        this._setMovePosX( evt );
        let posX = (this.curX - this.startCoords.clientX) / this.winWidth * 100; //% unit
        this._transformHeaderAnimation( posX, 'touchmove' );
        
        //async with Home Swipe
        if( this.props.idClass == 'header-swipe' ){
            let duration = '0ms';
            if( this.$remoteSwiper ){
                //0) moveSwiper-wrapper
                let unit = this._getUnit();
                this._setTransform(posX, unit, duration, this.$remoteSwiper);
            }
            this.valid = true;//touch event can trigger when move is ended
            this.isTransition = false;
        }
    }
    
    //Move Distance
    _setSohoSwipeMoveDistance( mode ) {
        let moveDistance = 100 / this.canSwipeNum;
        
        if( mode != 'buttonClick' ) {
            this._setDirection();
        }
        moveDistance = ( this.direction == 'next' )? moveDistance * -1 : moveDistance;
        
        //set current index
        if( this.direction == 'next' ){
            this.currentIndex = this.currentIndex + 1;
        } else if( this.direction == 'prev' ){
            this.currentIndex = this.currentIndex - 1;
        }
        
        if( this.direction == 'prev' && this.currentIndex < 0 ){
            this.currentIndex = 0;
            moveDistance = 0; //no moving
        } else if( this.direction == 'next' && this.currentIndex > this.canSwipeNum - 1 ) {
            this.currentIndex = this.canSwipeNum - 1;
            moveDistance = 0;
        }
        
        this._sendLogs();
        this._triggerCurrentSlide();
        this.sohoStyleCurrentPos += moveDistance;
        
        return this.sohoStyleCurrentPos;
    }
    _setDefalutMoveDistance() {
        let delta = this._setDirection();//parseInt( (this.curX - this.startCoords.clientX) / this.winWidth * 100 );
        let to = 0;
        if (delta > 25) {
            to = this.slideWidth; //100 is entire screen
        } else if (delta < -25) {
            to = -this.slideWidth;       
        }
        return to;
    }
    
    _getTargetIndex( to ) {
        let nextInx = (this.currentIndex + 1) % this.slides.length;
        let prevInx = (this.currentIndex - 1 < 0) ? this.slides.length - 1 : this.currentIndex - 1;
        let index = ( to < 0 )? nextInx : prevInx;
        if( to == 0 ) {//if to is 0, each slide
            index = (this.direction == 'next') ? nextInx : prevInx;
        }
        return index;
    }
    _playMoving( to, mode ) {
        if( to != 0 ){ //if to is 0, re position not need
            if( this.props.loop ){//
                //
                if( this.swipeRootElement ){
                    this.swipeRootElement.addEventListener("transitionend", this._endTransition, false);//if last option is true, stopPropergation not work
                    this.swipeRootElement.eventListnerParam = mode;
                }               
            }
        }
        
        this.isTransition = true;
        this._transformAnimation( to, mode );
    }
    _playMovingForHome( to, mode ) {
        if( to != 0 ){ //if to is 0, re position not need
            if( this.props.loop ){//
                //
                if( this.swipeRootElement ){
                    this.swipeRootElement.addEventListener("transitionend", this._endTransition, false);//if last option is true, stopPropergation not work
                    this.swipeRootElement.eventListnerParam = mode;
                }               
            }
        }
        
        this.isTransition = true;
        this._transformHeaderAnimation( to, mode );
    }
    // Move Animation
    _transformHeaderAnimation( to, mode ) {
        let duration = '0ms';
        switch( mode ) {
            case 'touchend':
                duration = '140ms';
                break;
            case 'touchmove':
                duration = '0ms';
                break;
        }
        
        //0) Move Swiper-wrapper
        if( this.swipeRootElement ){
            let unit = this._getUnit();
            this._setTransform(to, unit, duration, this.swipeRootElement);
        }
        
        //1) 
        for(let i=0; i<this.slides.length; i++) {
            let $innerSlide = this.slides[i].children[0];
            let posX = this.slideInnerXpos[i] - to;
            if( $innerSlide ) {
                let unit = this._getUnit();
                this._setTransform( posX, unit, duration, $innerSlide );
            }
        }
        
        this.valid = true;
        this.isTransition = false;
    }
    _transformAnimation( to, mode ) {
        let duration = '0ms';
        switch( mode ) {
            case 'touchend':
                duration = '140ms';
                break;
            case 'autoplay':
                duration = '600ms';
                break;
            case 'touchmove':
                duration = '0ms';
                break;
        }
        
        if( this.swipeRootElement ){
            let unit = this._getUnit();
            this._setTransform(to, unit, duration, this.swipeRootElement);
        }
        
        this.valid = true;
        this.isTransition = false;     
    }
    
    _setTransform( to, unit, duration, $element) {
        $element.style.webkitTransform = 'translate3d(' + to + unit + ',0,0)';
        $element.style.transform = 'translate3d(' + to + unit + ',0,0)';
        $element.style.transitionDuration = duration;
        $element.style.transitionTimingFunction = 'cubic-bezier(0.1, 0.57, 0.1, 1)';
    }
    
}











